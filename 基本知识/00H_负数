

----------------------
----- 基本描述 -----
----------------------

CPU只认 0和1 组成的二进制数值，不分正负值。

开发者主观的把，二进制分成了 有符号数 和 无符号数。




----------------------
---- 如何辨别正负数 ----
----------------------

通过 二进制的最高位 来辨别有符号数的正负，最高位为1代表负数，最高位为零代表正数。

八位字节环境中：

正数范围 0000 0000 ～ 0111 1111，即十进制 0 ～ 127

负数范围 1000 0000 ～ 1111 1111，即十进制 -128 ~ -1




------------------------------
----- 如何知道二进制的负数值 ----
------------------------------

用 0 减去一个 最高位为1 的二进制数值，就可以得到该二进制值表示的负数值


----- 案例一 -----

第一步解析：

  0000 0000
- 1111 1111

最低位的 0与1 相减，0因为值不够，需要向高位借1，导致除了第一位外，高位都变成了1

  1111 1110
- 1111 1111

第二步解析：

二进制值相减，是同位的值相减

  1111 1110
- 1111 1111
--------------
  0000 0001

最终得到的值是1，因为是负数，所以最终值为-1




----- 案例二 -----

0x80 ==> 1000 0000

作为无符号数，0x80 的值为 128

作为有符号数，其二进制最高位为1，代表负数

其负数值为: 0 - 1000 0000 ==> -128



----- 案例三 -----

0xFF ==> 1111 1111

作为无符号数，0xFF 的值为 255

作为有符号数，其二进制最高位为1，代表负数

  0000 0000     ; 除了第一位，其余的七位都会因为借位而变成1
-
  1111 1111     ; 二进制相减，相同位的值进行对应计算，同为0或1结果为0，不同值结果为1
--------------
  0000 0001

其负数值为 -1



--------------
---- neg ----
--------------

获取一个二进制的负数值

原理是用 0 减去指定的数值，操作数可以是 8位 或 16位的寄存器，或内存单元

neg al           ; 0减去al中的值，结果保存在al中
neg word [addr]  ; 0减去addr指向的地址，要操作的是一个16位值



--------------
---- cbw ----
--------------

cbw 指令没有操作数，操作码为98

将寄存器AL中的 有符号数 扩展到整个AX

正数用 0 扩展，负数用 1 扩展



--------------
---- cwd ----
--------------

没有操作数，只有操作码99

将寄存器 AX 中的有符号数扩展到 DX:AX

几乎所有的处理器指令(如:add,sub...)既能操作有符号数，也能操作无符号数

但个别指令除外，比如除法指令，乘法指令




------------------
---- 特需留意 ----
------------------

几乎所有的处理器指令 既能处理无符号数 和 有符号数

但有几条指令除外，比如除法指令和乘法指令

关于负数不做太多深究






