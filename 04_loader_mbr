
; 程序基本结构概述

; 1.被加载程序，所在的磁盘扇区逻辑号

; 2.被加载程序，要被存放到的内存地址

; 3.编写读取硬盘数据的代码段，将磁盘上的程序加载到内存中

; 4.执行被加载的程序





; 1.被加载程序，所在的磁盘扇区逻辑号
app_lba_start equ 5     ; 声明常数 5 ，被加载程序所在的起始逻辑扇区号为5
                        ; 逻辑扇区号是从 0值 开始计数的，逻辑扇区号5，实际上是第六个扇区

SECTION mbr align=16 vstart=0x7c00

jmp start


;2.被加载程序，要被存放到的内存地址

phy_base dd 0x10000     ; 用户程序被加载到的物理起始地址，8086的地址是20位的，0x00000 ～ 0xFFFFF
                        ; 因此使用 dd(4字节) 来声明空间

; 可用寄存器：ax,bx,cx,dx,si,di,ds,es
; si   ，保存逻辑扇区号的值 5
; es:di，保存程序要被加载到的起始内存地址
; bx   ，保存要读取的扇区数

start:


    ; 1.设置堆栈段和栈指针
    ; 过程调用时需要将一部分数据压入栈中

    mov ax,0
    mov ss,ax
    mov sp,ax


    ; 2.计算用户程序的起始逻辑段地址
    ; 用来指向用户程序要被加载到的位置

    mov ax,[cs:phy_base]          ; phy_base所在的位置，保存了用户程序被加载到的起始内存地址
    mov dx,[cs:phy_base+0x02]     ; 将内存地址，转换成逻辑段地址 ( phy_base dd 0x10000 )
    mov bx,16                     ; 除以16 等同于 右移4位，2*2*2*2=16
    div bx
    mov ds,ax                     ; 右移后，结果值被保存到了ax中，因为ax容量是16位的，因此只保存低16位的值
    mov es,ax                     ; 将 DS 和 ES 的值设置成用户程序的起始逻辑段地址


    ; 3.读取用户程序的第一扇区

    xor  di,di
    mov  si,app_lba_start         ; app_lba_start 代表起始逻辑扇区号
    xor  bx,bx                    ; 加载到DS:0x0000处
    call read_hard_disk_proc


    ; 4.判断整个程序占几个扇区

    mov ax,[0]    ; 用户程序的大小被写在了，用户程序的起始地址处，program_length  dd program_end
    mov dx,[2]    ; ax 和 dx 的组合，存放用户程序的大小值
    mov bx,512    ; 每扇区512字节
    div bx

    cmp dx,0      ;
    jne @1        ; 未除尽
    dec ax        ; 如果除尽，ax值减一，既可以得到接下来还要读取几个扇区数（减一是因为，已经读了一个扇区）

    @1:
        cmp ax,0
        je relocation  ; 如果程序小于512字节，不再读取扇区


    ; 5.读取剩余的扇区数
    mov  cx,ax  ; 要读取的剩余扇区数
    push ds     ; 连续读取扇区，需要更新 ds 数据段

    @repRead:
        mov ax,ds    ; 用户程序会被加载到 DS:BX 指向的内存地址处，但是一个段能存放的数据最多是0xffff
        add ax,0x20  ; 如果超过0xffff，地址值又会回到 0x0000
        mov ds,ax    ; 为了避免这问题发生，每读取一个新的扇区时，都将段地址值增加512字节，0x200==2*16*16==512，而段地址值被右移了四位

        xor bx,bx
        inc si       ; si加一，指向下一个扇区 (DI:SI，指向要读取的逻辑扇区号)

        call read_hard_disk_proc
        loop @repRead

    pop ds


    ; 5.用户程序重定位
    relocation:

        mov ax,[0x06]    ; 重定位用户程序入口点的段地址值
        mov dx,[0x08]
        call relocation_proc

        mov [0x06],ax    ; 段地址是16位的，只需将ax回填即可

    ; 开始处理段重定位表
    mov cx,[0x0a]    ; 需要重定位的项目数量
    mov bx,0x0c      ; ds已经指向了用户程序的起始内存地址，ds:bx指向要重定位的段地址

    relocation_loop:
        mov ax,[bx]
        mov dx,[bx+0x02]
        call relocation_proc

        mov [bx],ax
        add bx,4

        loop relocation_loop

        jmp far [0x04]



; ----- read_hard_disk_proc -----

; 从硬盘读取一个逻辑扇区

; DI:SI，指向要读取的逻辑扇区号

; DS:BX，数据要保存到 DS:BX 指向的目标地址


read_hard_disk_proc:

    push ax    ; 将通用寄存器中的数值入栈保存
    push bx    ; 结束过程调用时，出栈还原通用寄存器
    push cx
    push dx

    mov dx,0x1f2    ; dx指明要操作的端口号
    mov al,1        ; al存放要写入到端口的数据
    out dx,al       ; 端口号 0x1f2 中的数值，表明要读取的扇区数

    inc dx          ; 0x1f3～0x1f6，保存28位的逻辑扇区号值
    mov ax,si       ; DI:SI，保存了起始逻辑扇区号
    out dx,al

    inc dx          ; 0x1f4
    mov al,ah       ; 源操作数必须是 al 或 ax，因此需要将 ah 的值传输到 al中
    out dx,al

    inc dx          ; 0x1f5
    mov ax,di
    out dx,al

    inc dx          ; 0x1f6
    mov al,0xe0     ; 逻辑扇区号的值是28位的，因此 0x1f6端口 寄存器中，后4位的值用来指明 访问模式 和 访问的磁盘
    or  al,ah       ; e == 1110，最高三位全是1，表示使用LBA模式，第四位的0值代表访问主盘
    out dx,al

    inc dx          ; 0x1f7
    mov al,0x20     ; 读命令
    out dx,al

    .waits:          ; 给出了读取的逻辑扇区号，读取的扇区数量，以及读取命令，磁盘系统就开始准备了

        in  al,dx    ; 从端口中读数据
        and al,0x88
        cmp al,0x08  ; 只要磁盘系统准备完毕，与0x88进行and运算后，结果值一定是0x08
        jnz .waits   ; al不等于0x08，条件成立

    mov cx,256    ; 总共要读取的字数(一字等于2字节)
    mov dx,0x1f0  ; 从端口0x1f0中读取数据

    .readw:
        in  ax,dx    ; 从端口0x1f0中读取16位数据，并保存到ax中
        mov [bx],ax  ; 将读取到的数据，保存到 [ds:bx] 指向的地址中
        add bx,2
        loop .readw  ; 读取的次数由寄存器cx决定

    pop dx   ; 读取完毕后，还原通用寄存器
    pop cx
    pop bx
    pop ax

    ret  ; 结束过程调用



;----- relocation_proc -----

; 将程序中的段地址(汇编地址)，转成加载到内存后的逻辑段地址

; DX+AX组合，保存着要进行重定位的段地址

relocation_proc:

    add ax,[cs:phy_base]        ; 存在一个隐患，两个16位值相加，再存放到16位寄存器中，很可能出现值溢出的现象，这就导致最终结果错误
    add dx,[cs:phy_base+0x02]   ; 8086只有20位有效地址，其中低16位在ax中，剩余的4位在dx的低四位中
    shr ax,4                    ; ax向右移动4位，空出高4位来
    ror dx,4                    ; ror是循环右移指令，该指令把dx的低4位逐个转移到了高4位上
    and dx,0xf000               ; 将dx的低12位清零
    or  ax,dx                   ; 两者结合得到重定位后的逻辑段地址，保存在ax寄存器中

    ret

times 510-($-$$) db 0

db 0x55,0xaa
