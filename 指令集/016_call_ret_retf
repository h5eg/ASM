

---------------------
------ 过程调用 ------
---------------------

通过 call指令 跳转到目标代码处，在遇到过程返回指令 ret/retf，返回到跳转处，接着按顺序指向下一条指令


在跳转之前，会先将 CS:IP 的当前数值压入栈，接着将要跳转到的目标地址写入 CS:IP

执行完目标代码返回时，再将栈中的数值弹出，恢复 CS:IP 原先的值



-------------------------------
------ 16位段内相对跳转 ------
-------------------------------

只需提供一个相对于call指令的偏移值即可调用

偏移值是 标记 或 立即数

偏移数值是一位16位的有符号数值，因此有效范围值在 -32768 ～ 32767 之间

----- 案例 -----

call near proc   ; 关键字near不是必须的

...
...
...

proc:
    ...
    ...
    ...
    ret  ; 结束调用，返回调用处


----- 原理解析 -----

1.编译器会用 目标过程 的汇编地址，减去调用指令 call 所在的汇编地址，最终保留16位的结果值，作为相对偏移值(有符号数)

2.处理器执行到 call 指令时，会将当前 IP寄存器 中的数值，加上指令中的操作数，得到一个新的偏移地址

3.将当前 IP寄存器 中的数值压入栈，再把得到的新值写入到IP寄存器中

4.执行完过程调用后，处理器会把栈中的数值弹出，还原到IP寄存器中



-------------------------------
------ 16位段内偏移地址跳转 ------
-------------------------------

只需提供一个段内偏移地址就可以跳转，偏移地址值由 16位的寄存器 或 16位的内存单元给出

目标偏移地址直接由16位的数值给出，因此目标偏移地址的值范围是 0x0000～ 0xFFFF

所以，过程代码 可以位于段内的任何位置


------ 案例 ------

mov  cx,proc
call near cx    ; 关键字near不是必须的

...
...
...

proc:
    ...
    ...
    ...
    ret



----- 实现原理 ----

处理器执行到 call指令时，先将IP寄存器中的数值压入栈，接着会将 过程调用所在的偏移地址值 写入 到IP寄存器中。

执行完过程调用后，将压入栈中的数据弹出，还原 IP寄存器值。




-------------------------------
------ 16位跨段绝对地址调用 ------
-------------------------------

需要提供 过程代码 所在的 代码段地址 和 段内偏移地址。

16位是针对偏移地址，而非限定段地址。


call 0x0313:0x0400   ; 0x0313是偏移地址，0x0400是段地址

执行调用之前，会先将当前 CS和IP 的值先压入栈，再将目标地址值写入 CS和IP 中

执行完 过程代码 后，再将 CS和IP 的值还原。


虽然说是跨段调用，如果给出的 段地址:偏移地址 指向的是当前段，同样有效




-----------------------------------
------ 16位跨段间接绝对地址调用 ------
-----------------------------------

过程代码所在的 段地址：偏移地址 是间接给出的


call far [0x1234]

call far [proc]

call far [cx]


段地址：偏移地址 位于内存中，需要先读取内存才能获取到。


----- 案例 -----

pro1 dw 0x0123,0x0400  ; 0x0123是偏移地址，0x0400是段地址

...
...
...

call far [pro1]

...
...
...

pro1:
    ...
    ...
    ...
    retf




----------------------
------ ret/retf ------
----------------------

ret，近返回指令，当执行时，处理器只做一件事，从栈中弹出一个字到指令指针寄存器IP中。

retf，远返回指令，当执行时，处理器从栈中弹出两次2字节数据，将弹出的数据传送到寄存器IP 和 寄存器CS中。


ret  对应  call

retf 对应  call far




