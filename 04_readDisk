
; 程序基本结构概述

; 1.编写读取磁盘中的另一个程序

; 2.根据提供的逻辑扇区编号，读取磁盘上的其他程序

; 3.根据jmp指令，开始执行被加载的程序


app_lba_start equ 5     ; 声明常数 5 ，被加载程序所在的起始逻辑扇区号为5
                        ; 逻辑扇区号是从 0值 开始计数的，逻辑扇区号5，实际上是第六个扇区

SECTION mbr vstart=0x7c00   ; 汇编地址和偏移地址，都从0x7c00开始算起

jmp start

phy_base dd 0x10000     ; 被加载的程序，会被加载到的内存地址0x10000
                        ; 8086的地址是20位的，0x00000 ～ 0xFFFFF，因此使用 dd(4字节) 来声明空间

start:

    mov ax,0   ; 设置栈
    mov ss,ax
    mov sp,ax


    ; ----- 读取磁盘 -----
    ; 参数介绍：
    ; ES:SI，指向要读取的逻辑扇区号(LBA28编号模式，用28比特来表示逻辑扇区号，可以管理128GB的硬盘)
    ; DS:DI，指向数据要保存到的内存地址
    
    mov ax,0
    mov es,ax
    mov si,app_lba_start    ; 设置ES：SI

    mov ax,[phy_base]
    mov dx,[phy_base+0x02]
    mov bx,16   ; 除以16，等同于右移4位(2*2*2*2=16)，得到段地址
    div bx
    mov ds,ax   ; 设置DS：DI
    mov di,0

    call read_hard_disk_proc  ; 开始读取磁盘

    ; 重定位用户程序运行点的段地址值
    mov [0x02],ds   ; 将16位的段地址回填

    jmp far [0x00]  ; 跳转到用户程序中



; ----- read_hard_disk_proc -----

; 功能：从硬盘读取扇区

; 参数介绍：

; ES:SI，指向要读取的逻辑扇区号(LBA28编号模式，用28比特来表示逻辑扇区号，可以管理128GB的硬盘)

; DS:DI，指向数据要保存到的内存地址
         
;        存在的隐患：DI的值范围0x0000~0xFFFF，如果DI的值超过了0xFFFF，值会回到0x0000
;                  导致读取的数据超过0xFFFF字节，就会发生数据覆盖的现象
         
;        解决方案：以512字节为基本读取单元，每读取一个扇区，DS的值向前移动512，指向新的段
;                通过更新DS值的方式，解决了DI值受限的问题
;                让DS值加上0x20即可，0x200 == 2*16*16 == 512，0x200右移四位得到0x20

; 主硬盘分配的端口号：0x1f0 ~ 0x1f7
; 0x1f0(16位)，用于读写磁盘的数据都会经过该端口
; 0x1f1(8位) ，保存错误信息
; 0x1f2(8位) ，指明要操作的扇区数
; 0x1f3～0x1f6(共32位)，指明要操作的 磁盘 和 要操作的逻辑扇区号
; 0x1f7(8位) ，命令磁盘进行何种操作，以及保存磁盘状态

read_hard_disk_proc:

    ; 1.写入要读取的扇区数
    mov dx,0x1f2    ; dx指明要操作的端口号
    mov al,1       ; al存放要写入到端口的数据
    out dx,al       ; 端口号 0x1f2 中的数值，表明要读取的扇区数

    ; 2.写入要读取的逻辑扇区号
    inc dx          ; 端口号0x1f3～0x1f6，保存28位的逻辑扇区号值
    mov ax,si       ; ES:SI，保存了起始逻辑扇区号
    out dx,al       ; 将SI中的低八位值，写入到端口号0x1f3中

    inc dx          ; 0x1f4
    mov al,ah       ; 源操作数必须是 al 或 ax，因此需要将 ah 的值传输到 al中
    out dx,al       ; 将SI中的高八位值，写入到端口号0x1f4中

    inc dx          ; 0x1f5
    mov ax,es
    out dx,al       ; 将ES中的低八位值，写入到端口号0x1f5中

    inc dx          ; 端口0x1f6的寄存器中，后4位的值用来指明 访问模式 和 访问的磁盘
    mov al,0xe0     ; e == 1110，最高三位全是1，表示使用LBA模式，第四位的0值代表访问主盘
    or  al,ah
    out dx,al

    ; 3.发布读指令，等待磁盘系统准备完毕
    inc dx          ; 0x1f7
    mov al,0x20     ; 读命令
    out dx,al

    waiting:          ; 给出了读取的逻辑扇区号，读取的扇区数量，以及读取命令，磁盘系统就开始准备了
                     ; 硬盘开始准备时，会将该端口的最高位设置成1 (1010 0000)
                     ; 当硬盘准备好后，会将最高位设置成0，同时将第3位设置成1 （0010 1000）

        in  al,dx    ; 从端口0x1f7中读数据
        and al,0x88  ; 0x88 = 1000 1000
        cmp al,0x08  ; 只要磁盘系统准备完毕，与0x88进行and运算后，结果值一定是0x08
        jne waiting  ; al不等于0x08，继续等待

    ; 4.从端口0x1f0读取数据，端口0x1f0是16位的
    mov cx,256     ; 256*2=512
    mov dx,0x1f0

    readData:
        in   ax,dx       ; 从端口0x1f0中读取16位数据，并保存到ax中
        mov  [di],ax     ; 将读取到的数据，保存到 [ds:si] 指向的地址中
        add  di,2
        loop readData    ; 读取的次数由寄存器cx决定

    ret  ; 结束过程调用

times 510-($-$$) db 0 

db 0x55,0xaa




